---
phase: 01-ground-truth-tooling
plan: 03
type: execute
wave: 2
depends_on:
  - 02
files_modified:
  - scripts/generate_docs/main.go
  - scripts/generate_docs/parsers.go
  - scripts/generate_docs/parsers_test.go
  - .planning/INVENTORY.json
  - .planning/INVENTORY.md
  - Makefile
autonomous: true
requirements:
  - TOOL-03
  - TOOL-05

must_haves:
  truths:
    - "`.planning/INVENTORY.json` contains structured data for all 22 modules with commands, aliases, callbacks, message watchers, and disableable status"
    - "`.planning/INVENTORY.md` contains a summary table with columns: Module | Commands | Aliases | Callbacks | Watchers | Disableable | Has Docs"
    - "The inventory includes all 8 MultiCommand aliases (from Plan 02's parsers.go fix)"
    - "A module-to-docs mapping section shows which 4 modules lack docs directories (devs, help, users, and language/languages naming mismatch)"
    - "`bot_updates` is marked as internal/non-user-facing in the inventory"
  artifacts:
    - path: ".planning/INVENTORY.json"
      provides: "Machine-consumable canonical command inventory"
      contains: "\"module\""
    - path: ".planning/INVENTORY.md"
      provides: "Human-readable command inventory with module-to-docs mapping"
      contains: "Module"
    - path: "scripts/generate_docs/parsers_test.go"
      provides: "Unit tests for parseMessageWatchers extraction"
      contains: "TestParseMessageWatchers"
    - path: "scripts/generate_docs/main.go"
      provides: "-inventory flag for inventory generation mode"
      contains: "-inventory"
    - path: "Makefile"
      provides: "make check-docs target for docs drift detection"
      contains: "check-docs"
  key_links:
    - from: "scripts/generate_docs/main.go"
      to: "scripts/generate_docs/parsers.go:parseCommands"
      via: "-inventory flag triggers JSON/Markdown output instead of docs MDX"
      pattern: "inventory"
    - from: ".planning/INVENTORY.json"
      to: ".planning/INVENTORY.md"
      via: "Both generated from the same parsing pass"
      pattern: "has_docs_directory"
---

<objective>
Produce the canonical command inventory and module-to-docs mapping table that all subsequent phases depend on.

Purpose: Phase 2 needs structured data to diff against existing docs. The inventory is the single source of truth for what commands actually exist, which modules have docs, and which are undocumented. Without it, Phase 2 is guessing.

Output: `.planning/INVENTORY.json` (machine-consumable) and `.planning/INVENTORY.md` (human-readable) covering all 22 modules.
</objective>

<execution_context>
@/Users/divkix/.claude/get-shit-done/workflows/execute-plan.md
@/Users/divkix/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01/01-RESEARCH.md
@.planning/phases/01/01-02-SUMMARY.md

<interfaces>
<!-- From scripts/generate_docs/main.go — existing types and config -->

```go
// Config struct (line 19-33)
type Config struct {
    LocalesPath    string
    ModulesPath    string
    ConfigPath     string
    MigrationsPath string
    SampleEnvPath  string
    ChatStatusPath string
    DocsOutputPath string
    Verbose bool
    DryRun  bool
}

// Command struct (line 47-53)
type Command struct {
    Name        string
    Handler     string
    Module      string
    Disableable bool
    Aliases     []string
}

// Callback struct (line 86-91)
type Callback struct {
    Prefix     string
    Handler    string
    Module     string
    SourceFile string
}

// Existing parsing functions in parsers.go:
func parseCommands(modulesPath string) ([]Command, error)
func parseCallbacks(modulesPath string) ([]Callback, error)
// parseCallbacks already exists — use it for callback extraction
```

Existing flag registration pattern (main.go line 107-116):
```go
flag.StringVar(&config.LocalesPath, "locales", "locales", "Path to locales directory")
// ... more flags ...
flag.BoolVar(&config.DryRun, "dry-run", false, "Print what would be generated without writing files")
flag.Parse()
```

JSON inventory structure per CONTEXT.md decision:
```json
{
  "module": "bans",
  "source_file": "alita/modules/bans.go",
  "commands": [{"command": "ban", "aliases": [], "handler_group": 0, "disableable": true, "registration_pattern": "NewCommand"}],
  "callbacks": [...],
  "message_watchers": [...],
  "has_docs_directory": true,
  "docs_path": "docs/src/content/docs/commands/bans/"
}
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add -inventory flag and inventory generation to generate_docs</name>
  <files>scripts/generate_docs/main.go, scripts/generate_docs/parsers.go, scripts/generate_docs/parsers_test.go</files>
  <action>
**Step 0 (TDD RED): Write failing tests for parseMessageWatchers in `parsers_test.go`:**

Create or extend `scripts/generate_docs/parsers_test.go` (package `main`) with the following tests. These MUST fail before the implementation (RED phase):

**TestParseMessageWatchers_Basic:**
- Create a temporary directory with a `.go` file containing:
  ```go
  package modules

  var antispamModule = moduleStruct{moduleName: "antispam"}

  func LoadAntispam(dispatcher) {
      dispatcher.AddHandlerToGroup(handlers.NewMessage(anyFilter, antispamModule.checkSpam), 5)
  }
  ```
- Call `parseMessageWatchers(tempDir)`
- Assert: returned watchers include an entry with Handler == "checkSpam", Module == "antispam", HandlerGroup == 5

**TestParseMessageWatchers_NegativeHandlerGroup:**
- Create a temp `.go` file with a negative handler group:
  ```go
  dispatcher.AddHandlerToGroup(handlers.NewMessage(anyFilter, antifloodModule.checkFlood), -1)
  ```
- Assert: returned watcher has HandlerGroup == -1

**TestParseMessageWatchers_MultipleFiles:**
- Create two temp `.go` files each with different message watcher registrations
- Call `parseMessageWatchers(tempDir)`
- Assert: watchers from both files are returned

**TestParseMessageWatchers_EmptyDir:**
- Call `parseMessageWatchers` with an empty temp directory
- Assert: returns empty slice and no error

**TestParseMessageWatchers_NoWatchers:**
- Create a temp `.go` file with commands but NO message watcher registrations
- Assert: returns empty slice and no error

Run: `cd /Users/divkix/GitHub/Alita_Robot/scripts/generate_docs && go test -v -run "TestParseMessageWatchers" ./...` — tests MUST fail (function does not exist yet).

**Step 1 (TDD GREEN): Add message watcher parser to parsers.go:**

Add a new struct and function to `parsers.go`:

```go
// MessageWatcher represents a message handler registration
type MessageWatcher struct {
    Handler      string
    Module       string
    HandlerGroup int
    SourceFile   string
}
```

Add `parseMessageWatchers(modulesPath string) ([]MessageWatcher, error)` function:
- Use regex: `dispatcher\.AddHandlerToGroup\s*\(\s*handlers\.NewMessage\s*\([^,]+,\s*(\w+)\.(\w+)\s*\)\s*,\s*(-?\d+)\s*\)`
- Walk all `.go` files in modulesPath
- For each match: extract handler name (group 2), module variable (group 1), handler group number (group 3, parse as int)
- Resolve module name using the same `moduleNamePattern` approach as `parseCommands`
- Return the list of watchers

Run: `cd /Users/divkix/GitHub/Alita_Robot/scripts/generate_docs && go test -v -run "TestParseMessageWatchers" ./...` — all tests MUST pass (GREEN).

**Step 2: Add `-inventory` flag and `generateInventory()` to `main.go`:**

Add a new bool flag:
```go
var inventoryMode bool
flag.BoolVar(&inventoryMode, "inventory", false, "Generate canonical command inventory instead of docs")
```

After `flag.Parse()` and project root detection, add an early return path:
```go
if inventoryMode {
    if err := generateInventory(projectRoot); err != nil {
        log.Fatalf("Failed to generate inventory: %v", err)
    }
    return
}
```

Implement `generateInventory(projectRoot string) error`:

1. Call `parseCommands(filepath.Join(projectRoot, config.ModulesPath))` to get all commands
2. Call `parseCallbacks(filepath.Join(projectRoot, config.ModulesPath))` to get all callbacks
3. Call `parseMessageWatchers(filepath.Join(projectRoot, config.ModulesPath))` to get all watchers
4. List all `.go` files in `alita/modules/` — extract module names (strip `.go` suffix, skip helper files: `helpers.go`, `moderation_input.go`, `callback_codec.go`, `callback_parse_overwrite.go`, `chat_permissions.go`, `connections_auth.go`, `rules_format.go`)
5. For each module, check if `docs/src/content/docs/commands/{module_name}/` exists:
   - Handle naming mismatches: `mute` -> `mutes`, `language` -> `languages`
   - Check using `os.Stat()`
6. Group commands, callbacks, and watchers by module name
7. Build the inventory JSON structure per the CONTEXT.md decision format
8. Mark `bot_updates` as `"internal": true` with zero commands
9. Write `.planning/INVENTORY.json` (pretty-printed with `json.MarshalIndent`)
10. Write `.planning/INVENTORY.md` with:
    - Summary statistics (total modules, total commands, total callbacks, total watchers)
    - Summary table: Module | Commands | Aliases | Callbacks | Watchers | Disableable Count | Has Docs
    - Module-to-Docs Mapping section listing all 22 modules with their docs directory status
    - Highlight the 4 modules with no docs: devs, help, users (missing entirely), language (naming mismatch with `languages/`)

**Important path handling:** The `generate_docs` script is invoked from its own directory (`cd scripts/generate_docs && go run .`). The `projectRoot` is found via `findProjectRoot()` which walks up to find `go.mod`. The inventory output paths (`.planning/INVENTORY.json` and `.planning/INVENTORY.md`) must be relative to projectRoot. Use `filepath.Join(projectRoot, ".planning", "INVENTORY.json")`.

**Important:** Ensure the `.planning/` directory exists before writing. Use `os.MkdirAll(filepath.Join(projectRoot, ".planning"), 0o755)`.
  </action>
  <verify>
    <automated>cd /Users/divkix/GitHub/Alita_Robot/scripts/generate_docs && go run . -inventory && test -f /Users/divkix/GitHub/Alita_Robot/.planning/INVENTORY.json && test -f /Users/divkix/GitHub/Alita_Robot/.planning/INVENTORY.md && echo "INVENTORY GENERATED"</automated>
  </verify>
  <done>`-inventory` flag works. Both `.planning/INVENTORY.json` and `.planning/INVENTORY.md` are generated. JSON contains 22 modules. All 8 MultiCommand aliases appear. `bot_updates` is marked as internal.</done>
</task>

<task type="auto">
  <name>Task 2: Verify inventory completeness and module-to-docs mapping accuracy</name>
  <files>.planning/INVENTORY.json, .planning/INVENTORY.md, Makefile</files>
  <action>
**Step 1: Verify inventory completeness against the codebase:**

Run the inventory generation:
```bash
cd /Users/divkix/GitHub/Alita_Robot/scripts/generate_docs && go run . -inventory
```

Then cross-check the output:

1. **Module count:** Verify `.planning/INVENTORY.json` contains exactly 22 modules (or the correct count after excluding non-module helper files). List them and compare against `ls alita/modules/*.go` minus the known helper files.

2. **MultiCommand aliases:** Verify all 8 aliases appear:
   ```bash
   grep -c '"remallbl"\|"rmallbl"\|"markdownhelp"\|"formatting"\|"privnote"\|"privatenotes"\|"resetrules"\|"clearrules"' .planning/INVENTORY.json
   ```
   Expected: 8 matches.

3. **Disableable commands:** Cross-check against actual `misc.AddCmdToDisableable()` calls:
   ```bash
   grep -r 'AddCmdToDisableable' alita/modules/ | wc -l
   ```
   Compare count against disableable entries in INVENTORY.json.

4. **Callbacks:** Verify callback count is reasonable (check `parseCallbacks` output against `grep -r 'handlers.NewCallback' alita/modules/ | wc -l`).

5. **Message watchers:** Verify watcher count matches `grep -r 'AddHandlerToGroup.*NewMessage' alita/modules/ | wc -l`.

**Step 2: Verify module-to-docs mapping in INVENTORY.md:**

Confirm the mapping table shows:
- `devs` — no docs directory
- `help` — no docs directory
- `users` — no docs directory
- `language` — maps to `languages/` directory (naming mismatch noted)
- `mute` — maps to `mutes/` directory (naming mismatch noted)
- `bot_updates` — internal module, no docs directory (intentional)
- All other modules — have matching docs directories

**Step 3: If any discrepancies found**, fix the inventory generation code and re-run. The inventory must be accurate — Phase 2 depends on it entirely.

**Step 4: Add `make check-docs` and `make inventory` targets to Makefile:**

Add both targets after the existing `generate-docs` target in `/Users/divkix/GitHub/Alita_Robot/Makefile`.

**Required — `make check-docs` (per locked Decision 4 in CONTEXT.md):**
```makefile
check-docs:
	@echo "Checking docs generation for drift..."
	@cd scripts/generate_docs && $(GO_CMD) run .
```
This runs the patched `generate_docs` script as a smoke test for docs drift. It exercises the MultiCommand parser fix and confirms the script runs without errors. Add `check-docs` to the `.PHONY` line at the top of the Makefile.

**Optional — `make inventory`:**
```makefile
inventory:
	@echo "Generating canonical command inventory..."
	@cd scripts/generate_docs && $(GO_CMD) run . -inventory
	@echo "Inventory written to .planning/INVENTORY.json and .planning/INVENTORY.md"
```
Add `inventory` to the `.PHONY` line as well.
  </action>
  <verify>
    <automated>cd /Users/divkix/GitHub/Alita_Robot && python3 -c "import json; d=json.load(open('/Users/divkix/GitHub/Alita_Robot/.planning/INVENTORY.json')); mods=[m['module'] for m in d]; print(f'{len(d)} modules'); assert len(d) >= 20, f'Expected 20+ modules, got {len(d)}'; assert any('remallbl' in str(m) for m in d), 'Missing MultiCommand aliases'; print('INVENTORY VALID')"</automated>
  </verify>
  <done>INVENTORY.json contains all modules with accurate command/callback/watcher data. INVENTORY.md has a complete summary table and module-to-docs mapping. All 8 MultiCommand aliases are present. 4 modules without docs directories are identified. `bot_updates` is marked as internal. `make check-docs` target exists and runs successfully. The inventory is ready for Phase 2 consumption.</done>
</task>

</tasks>

<verification>
1. `.planning/INVENTORY.json` exists and contains valid JSON with 20+ module entries
2. `.planning/INVENTORY.md` exists with summary table and module-to-docs mapping
3. All 8 MultiCommand aliases (remallbl, rmallbl, markdownhelp, formatting, privnote, privatenotes, resetrules, clearrules) appear in the inventory
4. Module-to-docs mapping correctly identifies: devs (no docs), help (no docs), users (no docs), language (maps to languages/), bot_updates (internal)
5. `make generate-docs` still works (no regression — the -inventory flag is an alternative mode, not a replacement)
6. `cd /Users/divkix/GitHub/Alita_Robot/scripts/generate_docs && go test -v -run "TestParseMessageWatchers" ./...` — all watcher parser tests pass
7. `make check-docs` runs successfully (smoke test for docs generation drift)
</verification>

<success_criteria>
- Canonical inventory covers all 22 modules with every command, alias, callback, message watcher, and disableable status
- Module-to-docs mapping table exists showing 4 modules with no docs directories and naming mismatches
- `bot_updates` is explicitly marked as internal/non-user-facing
- Inventory data matches actual codebase registrations (verified by cross-checking grep counts)
- Phase 2 can consume INVENTORY.json programmatically to diff against existing docs
- `parseMessageWatchers()` has unit tests covering: basic extraction, negative handler groups, multiple files, empty directory, and no-watchers cases
- `make check-docs` target exists in Makefile and runs the patched generate_docs script as a docs drift smoke test
</success_criteria>

<output>
After completion, create `.planning/phases/01/01-03-SUMMARY.md`
</output>
