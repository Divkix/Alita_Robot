---
phase: 01-ground-truth-tooling
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/generate_docs/parsers.go
  - scripts/generate_docs/parsers_test.go
  - docs/package.json
  - docs/astro.config.mjs
autonomous: true
requirements:
  - TOOL-02
  - TOOL-04

must_haves:
  truths:
    - "`make generate-docs` output includes all 8 MultiCommand aliases: remallbl, rmallbl, markdownhelp, formatting, privnote, privatenotes, resetrules, clearrules"
    - "`starlight-links-validator` is listed in docs/package.json devDependencies"
    - "`bun run build` in docs/ invokes the link validator and either passes or fails with specific broken link errors (both are valid outcomes)"
  artifacts:
    - path: "scripts/generate_docs/parsers_test.go"
      provides: "Unit tests for MultiCommand regex extraction"
      contains: "TestParseCommands_MultiCommand"
    - path: "scripts/generate_docs/parsers.go"
      provides: "Extended command parser with MultiCommand support"
      contains: "cmdDecorator"
    - path: "docs/package.json"
      provides: "starlight-links-validator dev dependency"
      contains: "starlight-links-validator"
    - path: "docs/astro.config.mjs"
      provides: "Link validator plugin configuration"
      contains: "starlightLinksValidator"
  key_links:
    - from: "scripts/generate_docs/parsers.go:parseCommands"
      to: "multiCommandPattern regex"
      via: "Second regex pattern added alongside existing newCommandPattern"
      pattern: "cmdDecorator\\.MultiCommand"
    - from: "docs/astro.config.mjs"
      to: "starlight-links-validator"
      via: "Plugin added to Starlight plugins array"
      pattern: "starlightLinksValidator"
---

<objective>
Patch the `generate_docs` parser to extract `cmdDecorator.MultiCommand()` registrations and install `starlight-links-validator` in the Astro docs build.

Purpose: The MultiCommand blindspot means 8 commands are invisible to the docs generator — Phase 2 cannot produce accurate command documentation without this fix. The link validator gates Phase 5 final verification and catches broken links before Cloudflare deployment.

Output: Patched parsers.go with MultiCommand regex, unit tests proving extraction works, and a configured link validator that runs on every `astro build`.
</objective>

<execution_context>
@/Users/divkix/.claude/get-shit-done/workflows/execute-plan.md
@/Users/divkix/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01/01-RESEARCH.md

<interfaces>
<!-- Key types and functions from scripts/generate_docs/ -->

```go
// From main.go line 47-53: Command struct
type Command struct {
    Name        string
    Handler     string
    Module      string
    Disableable bool
    Aliases     []string
}

// From parsers.go line 138: The function to patch
func parseCommands(modulesPath string) ([]Command, error)
```

Existing regex in parseCommands (parsers.go line 143):
```go
newCommandPattern := regexp.MustCompile(`handlers\.NewCommand\s*\(\s*"([^"]+)"\s*,\s*(\w+)\.(\w+)\s*\)`)
```

The 4 MultiCommand call sites to capture:
```go
// alita/modules/blacklists.go
cmdDecorator.MultiCommand(dispatcher, []string{"remallbl", "rmallbl"}, blacklistsModule.rmAllBlacklists)

// alita/modules/formatting.go
cmdDecorator.MultiCommand(dispatcher, []string{"markdownhelp", "formatting"}, formattingModule.markdownHelp)

// alita/modules/notes.go
cmdDecorator.MultiCommand(dispatcher, []string{"privnote", "privatenotes"}, notesModule.privNote)

// alita/modules/rules.go
cmdDecorator.MultiCommand(dispatcher, []string{"resetrules", "clearrules"}, rulesModule.clearRules)
```

Existing docs/astro.config.mjs plugins array:
```javascript
plugins: [starlightThemeBlack({}), starlightLlmsTxt()],
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MultiCommand regex to parsers.go with unit tests</name>
  <files>scripts/generate_docs/parsers.go, scripts/generate_docs/parsers_test.go</files>
  <action>
**Step 1: Create test file FIRST** (`scripts/generate_docs/parsers_test.go`):

Write tests in `package main` that exercise `parseCommands()`:

**TestParseCommands_MultiCommand:**
- Create a temporary directory with a `.go` file containing:
  ```go
  package modules

  var blacklistsModule = moduleStruct{moduleName: "blacklists"}

  func LoadBlacklists(dispatcher) {
      cmdDecorator.MultiCommand(dispatcher, []string{"remallbl", "rmallbl"}, blacklistsModule.rmAllBlacklists)
  }
  ```
- Call `parseCommands(tempDir)`
- Assert: returned commands include entries for both "remallbl" and "rmallbl"
- Assert: both commands have Module == "blacklists"

**TestParseCommands_MultiCommand_AllSites:**
- Create temp `.go` files mimicking all 4 real MultiCommand call sites
- Call `parseCommands(tempDir)`
- Assert: all 8 aliases are present: remallbl, rmallbl, markdownhelp, formatting, privnote, privatenotes, resetrules, clearrules

**TestParseCommands_Mixed:**
- Create a temp file with BOTH `handlers.NewCommand("ban", ...)` and `cmdDecorator.MultiCommand(...)` patterns
- Assert: both the NewCommand and MultiCommand registrations are extracted

Run the tests — they MUST fail because parsers.go does not yet have MultiCommand support.

**Step 2: Patch `parseCommands()` in `scripts/generate_docs/parsers.go`:**

After the existing `newCommandPattern` declaration (line 143), add:
```go
multiCommandPattern := regexp.MustCompile(
    `cmdDecorator\.MultiCommand\s*\(\s*\w+\s*,\s*\[\]string\s*\{([^}]+)\}\s*,\s*(\w+)\.(\w+)\s*\)`,
)
```

Inside the file-reading loop (after the existing `cmdMatches` processing block that processes `newCommandPattern` matches), add:
```go
// Extract MultiCommand registrations (cmdDecorator.MultiCommand(dispatcher, []string{...}, handler))
multiMatches := multiCommandPattern.FindAllStringSubmatch(content, -1)
for _, match := range multiMatches {
    if len(match) >= 4 {
        aliasesRaw := match[1] // e.g., `"remallbl", "rmallbl"`
        moduleVar := match[2]  // e.g., "blacklistsModule"
        handler := match[3]    // e.g., "rmAllBlacklists"

        // Parse individual alias strings from the slice literal
        aliasPattern := regexp.MustCompile(`"([^"]+)"`)
        aliasMatches := aliasPattern.FindAllStringSubmatch(aliasesRaw, -1)

        var aliases []string
        for _, a := range aliasMatches {
            if len(a) > 1 {
                aliases = append(aliases, a[1])
            }
        }

        // Resolve module name from the module variable
        modName := moduleName
        if name, ok := moduleNames[moduleVar]; ok {
            modName = name
        }

        // Register each alias as a command
        for _, alias := range aliases {
            commands = append(commands, Command{
                Name:        alias,
                Handler:     handler,
                Module:      modName,
                Disableable: disableableCmds[alias],
                Aliases:     aliases, // All aliases in this MultiCommand group
            })
        }
    }
}
```

**Important:** The `moduleNames` map is keyed by the variable name (e.g., `"blacklistsModule"`). Check how the existing `moduleNamePattern` regex populates it — the capture group is `(\w+)Module` which captures just the prefix. Verify the map key format and adjust the lookup accordingly. If the map key is `"blacklists"` (without "Module" suffix), use `moduleNames[moduleVar]` where `moduleVar` is `"blacklistsModule"` — this won't match. In that case, strip the "Module" suffix: `moduleNames[strings.TrimSuffix(moduleVar, "Module")]`.

**Step 3: Run tests — all should pass (GREEN).**

Then run `make generate-docs` from the project root and verify the 8 MultiCommand aliases appear in the generated output.
  </action>
  <verify>
    <automated>cd /Users/divkix/GitHub/Alita_Robot/scripts/generate_docs && go test -v -run "TestParseCommands" ./...</automated>
  </verify>
  <done>All MultiCommand tests pass. `parseCommands()` extracts all 8 MultiCommand aliases (remallbl, rmallbl, markdownhelp, formatting, privnote, privatenotes, resetrules, clearrules) from the codebase. `make generate-docs` includes these commands in output.</done>
</task>

<task type="auto">
  <name>Task 2: Install and configure starlight-links-validator</name>
  <files>docs/package.json, docs/astro.config.mjs</files>
  <action>
**Step 1: Install the package:**

```bash
cd /Users/divkix/GitHub/Alita_Robot/docs && bun add -D starlight-links-validator
```

This adds `starlight-links-validator` to `devDependencies` in `docs/package.json`.

**Step 2: Configure in `docs/astro.config.mjs`:**

Add the import at the top of the file, after the existing imports:
```javascript
import starlightLinksValidator from 'starlight-links-validator';
```

Add the plugin to the `plugins` array in the `starlight()` config. Change:
```javascript
plugins: [starlightThemeBlack({}), starlightLlmsTxt()],
```
To:
```javascript
plugins: [starlightThemeBlack({}), starlightLlmsTxt(), starlightLinksValidator()],
```

No configuration options needed — the defaults match the locked decision:
- `errorOnRelativeLinks: true` (catches `./test` style links)
- `errorOnInvalidHashes: true` (catches broken anchor links)
- External links ignored by default
- Only runs during `astro build`, not `astro dev`

**Step 3: Test the build:**

```bash
cd /Users/divkix/GitHub/Alita_Robot/docs && bun run build
```

**Expected outcomes (BOTH are valid):**
- Build passes cleanly: the docs have no broken internal links. Record this.
- Build fails with specific broken link errors: the plugin is working correctly and found pre-existing broken links. Record which links are broken — these become Phase 2 tasks. Do NOT add `exclude` patterns to suppress errors. Do NOT treat this as a failure of the task.

**Step 4: If build fails with broken links:**
Document the broken links in the plan summary. These are FINDINGS, not failures. The whole point of TOOL-04 is to expose broken links.

If build fails for a NON-link-validator reason (e.g., Astro version incompatibility, missing dependency), that IS a real issue — investigate and fix.
  </action>
  <verify>
    <automated>cd /Users/divkix/GitHub/Alita_Robot/docs && grep -q "starlight-links-validator" package.json && grep -q "starlightLinksValidator" astro.config.mjs && echo "CONFIGURED"</automated>
  </verify>
  <done>`starlight-links-validator` is in docs/package.json devDependencies. `starlightLinksValidator()` is in the plugins array in docs/astro.config.mjs. Build has been run and results documented (either clean pass or broken links listed as findings).</done>
</task>

</tasks>

<verification>
1. `cd scripts/generate_docs && go test -v ./...` — all MultiCommand tests pass
2. `make generate-docs` — output includes remallbl, rmallbl, markdownhelp, formatting, privnote, privatenotes, resetrules, clearrules
3. `grep "starlight-links-validator" docs/package.json` — present in devDependencies
4. `grep "starlightLinksValidator" docs/astro.config.mjs` — present in plugins array
5. `cd docs && bun run build` — runs link validator (pass or broken link findings are both valid)
</verification>

<success_criteria>
- `parseCommands()` extracts all 8 MultiCommand aliases alongside existing NewCommand registrations
- Unit tests prove MultiCommand regex works in isolation and mixed with NewCommand patterns
- `starlight-links-validator` is installed and configured to run on every `astro build`
- Any broken links found are documented as findings, not suppressed
</success_criteria>

<output>
After completion, create `.planning/phases/01/01-02-SUMMARY.md`
</output>
